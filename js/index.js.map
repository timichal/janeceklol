{
  "version": 3,
  "sources": ["../../build/js/index.js"],
  "sourcesContent": ["const pickRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];\r\n\r\nconst generators = [\r\n  { url: \"https://source.unsplash.com/800x800?people\", weight: 10 },\r\n  { url: \"https://source.unsplash.com/800x800?group\", weight: 5 },\r\n];\r\n\r\nconst unrolledGenerators = generators.flatMap(({ url, weight }) => Array(weight).fill(url));\r\n\r\nlet displayText = false;\r\nlet currentText = \"\";\r\n\r\nconst imageReader = new FileReader();\r\nlet currentImage = new Image();\r\n\r\nconst rerollImage = async () => {\r\n  const imageData = await fetch(pickRandom(unrolledGenerators));\r\n\r\n  return new Promise((resolve) => {\r\n    const image = new Image();\r\n\r\n    image.addEventListener(\"load\", () => {\r\n      currentImage = image;\r\n      resolve();\r\n    });\r\n\r\n    image.crossOrigin = \"anonymous\";\r\n    image.src = imageData.url;\r\n  });\r\n};\r\n\r\nconst canvas = document.getElementById(\"picture\");\r\nconst ctx = canvas.getContext(\"2d\");\r\n\r\nconst getCanvasInfo = () => {\r\n  const canvasRect = canvas.getBoundingClientRect();\r\n  return {\r\n    offsetX: canvasRect.left,\r\n    offsetY: canvasRect.top,\r\n    canvasScale: canvasRect.width / 800,\r\n  };\r\n};\r\n\r\nlet { offsetX, offsetY, canvasScale } = getCanvasInfo();\r\n\r\nlet isDragging = false;\r\nlet startX;\r\nlet startY;\r\n\r\nconst overlayImage = new Image();\r\noverlayImage.src = \"public/janecek.png\";\r\nconst initialWidth = 493;\r\nconst initialHeight = 897;\r\nconst descale = 1.8;\r\nconst overlayImageCoords = {\r\n  x: 500,\r\n  y: 800 - (initialHeight / descale),\r\n  width: initialWidth / descale,\r\n  height: initialHeight / descale,\r\n};\r\n\r\nconst onMouseDown = (e) => {\r\n  const isTouch = !!e.touches;\r\n  // mouse position\r\n  const mx = Number((isTouch ? e.touches[0].clientX : e.clientX) - offsetX);\r\n  const my = Number((isTouch ? e.touches[0].clientY : e.clientY) - offsetY);\r\n\r\n  // overlay image position (with scaling)\r\n  const ix = overlayImageCoords.x * canvasScale;\r\n  const iy = overlayImageCoords.y * canvasScale;\r\n  const iw = overlayImageCoords.width * canvasScale;\r\n  const ih = overlayImageCoords.height * canvasScale;\r\n\r\n  if (mx > ix && mx < ix + iw && my > iy && my < iy + ih) {\r\n    isDragging = true;\r\n  }\r\n\r\n  startX = mx;\r\n  startY = my;\r\n};\r\n\r\ncanvas.addEventListener(\"mousedown\", onMouseDown);\r\ncanvas.addEventListener(\"touchstart\", onMouseDown);\r\n\r\ncanvas.addEventListener(\"mouseup\", () => { isDragging = false; });\r\n\r\nconst setFile = (file) => {\r\n  if (!file.type.startsWith(\"image/\")) {\r\n    return;\r\n  }\r\n\r\n  imageReader.readAsDataURL(file);\r\n};\r\n\r\ncanvas.addEventListener(\"dragover\", (e) => e.preventDefault());\r\n\r\nfunction renderWrappedText(ctx, text, x, y, maxWidth, lineHeight) {\r\n  const lines = text.split(\"\\n\");\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const words = lines[i].split(\" \");\r\n    let line = \"\";\r\n\r\n    for (let n = 0; n < words.length; n++) {\r\n      const testLine = `${line + words[n]} `;\r\n      const metrics = ctx.measureText(testLine);\r\n      const testWidth = metrics.width;\r\n      if (testWidth > maxWidth && n > 0) {\r\n        ctx.fillText(line, x, y);\r\n        line = `${words[n]} `;\r\n        y += lineHeight;\r\n      } else {\r\n        line = testLine;\r\n      }\r\n    }\r\n\r\n    ctx.fillText(line, x, y);\r\n    y += lineHeight;\r\n  }\r\n}\r\n\r\ncanvas.addEventListener(\"drop\", (e) => {\r\n  e.preventDefault();\r\n  if (!e.dataTransfer || e.dataTransfer.files.length <= 0) {\r\n    return;\r\n  }\r\n\r\n  setFile(e.dataTransfer.files[0]);\r\n});\r\n\r\nconst repaintImage = async () => {\r\n  // clear to black (for transparent images)\r\n  ctx.fillStyle = \"black\";\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n  // scale image to always fill the canvas\r\n  const scaleX = canvas.width / currentImage.width;\r\n  const scaleY = canvas.height / currentImage.height;\r\n  const scale = Math.max(scaleX, scaleY);\r\n  ctx.setTransform(scale, 0, 0, scale, 0, 0);\r\n  ctx.drawImage(currentImage, 0, 0);\r\n  ctx.setTransform(); // reset so that everything else is normal size\r\n\r\n  ctx.drawImage(overlayImage, overlayImageCoords.x, overlayImageCoords.y, overlayImageCoords.width, overlayImageCoords.height);\r\n\r\n  if (displayText) {\r\n    const fontSize = 95;\r\n    const lineHeight = 95;\r\n    const maxWidth = 700;\r\n    ctx.font = `bold ${fontSize}px 'bc-novatica-cyr'`;\r\n    const line = currentText || \"Tohle s memy\";\r\n    const x = 50;\r\n    const y = 350;\r\n    ctx.fillStyle = \"#f9dc4d\";\r\n    ctx.textBaseline = \"top\";\r\n    ctx.fillStyle = \"yellow\";\r\n    renderWrappedText(ctx, line, x, y, maxWidth, lineHeight);\r\n  }\r\n};\r\n\r\nconst onMove = (e) => {\r\n  const isTouch = !!e.touches;\r\n  // mouse position\r\n  const mx = Number((isTouch ? e.touches[0].clientX : e.clientX) - offsetX);\r\n  const my = Number((isTouch ? e.touches[0].clientY : e.clientY) - offsetY);\r\n\r\n  // overlay image position (with scaling)\r\n  const ix = overlayImageCoords.x * canvasScale;\r\n  const iy = overlayImageCoords.y * canvasScale;\r\n  const iw = overlayImageCoords.width * canvasScale;\r\n  const ih = overlayImageCoords.height * canvasScale;\r\n\r\n  // fancy cursor\r\n  if (mx > ix && mx < ix + iw && my > iy && my < iy + ih) {\r\n    canvas.style.cursor = \"pointer\";\r\n  } else {\r\n    canvas.style.cursor = \"initial\";\r\n  }\r\n\r\n  if (isDragging) {\r\n    // calculate the distance the mouse has moved\r\n    // since the last mousemove\r\n    const dx = mx - startX;\r\n    const dy = my - startY;\r\n\r\n    overlayImageCoords.x += dx / canvasScale;\r\n    overlayImageCoords.y += dy / canvasScale;\r\n\r\n    repaintImage();\r\n\r\n    // reset the starting mouse position for the next mousemove\r\n    startX = mx;\r\n    startY = my;\r\n  }\r\n};\r\n\r\ncanvas.addEventListener(\"mousemove\", onMove);\r\ncanvas.addEventListener(\"touchmove\", onMove);\r\n\r\nimageReader.addEventListener(\"load\", (e) => {\r\n  currentImage = new Image();\r\n  currentImage.addEventListener(\"load\", () => repaintImage());\r\n  currentImage.src = e.target.result;\r\n});\r\n\r\nconst buttonRandomImg = document.getElementById(\"randomize\");\r\nbuttonRandomImg.addEventListener(\"click\", async () => {\r\n  await rerollImage();\r\n  repaintImage();\r\n});\r\n\r\nconst inputCustomImg = document.getElementById(\"customImage\");\r\ninputCustomImg.addEventListener(\"change\", (e) => {\r\n  e.preventDefault();\r\n  if (e.target.files.length <= 0) {\r\n    return;\r\n  }\r\n  setFile(e.target.files[0]);\r\n});\r\nconst buttonCustomImg = document.getElementById(\"customImageBtn\");\r\nbuttonCustomImg.addEventListener(\"click\", () => {\r\n  inputCustomImg.click();\r\n});\r\n\r\nconst toggleText = document.getElementById(\"toggleText\");\r\nconst inputCustom = document.getElementById(\"customText\");\r\ntoggleText.addEventListener(\"click\", () => {\r\n  displayText = !displayText;\r\n  toggleText.innerText = toggleText.innerText === \"Přidat text\" ? \"Odebrat text\" : \"Přidat text\";\r\n  repaintImage();\r\n});\r\n\r\nconst replaceWithCustomText = async (e) => {\r\n  if (e.type === \"input\" || inputCustom.value) {\r\n    currentText = inputCustom.value;\r\n    repaintImage();\r\n  }\r\n};\r\ninputCustom.addEventListener(\"click\", replaceWithCustomText);\r\ninputCustom.addEventListener(\"input\", replaceWithCustomText);\r\n\r\nconst slider = document.getElementById(\"slider\");\r\nlet oldWidth = overlayImageCoords.width;\r\nlet oldHeight = overlayImageCoords.height;\r\nconst zoomImage = (value) => {\r\n  overlayImageCoords.width = initialWidth * (value / 100);\r\n  overlayImageCoords.height = initialHeight * (value / 100);\r\n\r\n  overlayImageCoords.x += (oldWidth - overlayImageCoords.width) / 2;\r\n  overlayImageCoords.y += (oldHeight - overlayImageCoords.height) / 2;\r\n\r\n  oldWidth = overlayImageCoords.width;\r\n  oldHeight = overlayImageCoords.height;\r\n  repaintImage();\r\n};\r\nslider.addEventListener(\"input\", (e) => zoomImage(e.target.value));\r\n\r\nconst downloadLinkReal = document.createElement(\"a\");\r\ndownloadLinkReal.setAttribute(\"download\", \"TohleJsmeMy.jpg\");\r\nconst linkSave = document.getElementById(\"save\");\r\nlinkSave.addEventListener(\"click\", (e) => {\r\n  e.preventDefault();\r\n  downloadLinkReal.setAttribute(\"href\", canvas.toDataURL(\"image/jpeg\").replace(\"image/jpeg\", \"image/octet-stream\"));\r\n  downloadLinkReal.click();\r\n});\r\n\r\nwindow.addEventListener(\"resize\", () => {\r\n  const resizedCanvasInfo = getCanvasInfo();\r\n  offsetX = resizedCanvasInfo.offsetX;\r\n  offsetY = resizedCanvasInfo.offsetY;\r\n  canvasScale = resizedCanvasInfo.canvasScale;\r\n});\r\n\r\nrerollImage()\r\n  .then(() => repaintImage());\r\n\r\n// /////////////////////\r\nconst evCache = [];\r\nlet prevDiff = -1;\r\n\r\ncanvas.addEventListener(\"pointerdown\", (e) => evCache.push(e));\r\ncanvas.addEventListener(\"pointermove\", (e) => {\r\n  for (let i = 0; i < evCache.length; i++) {\r\n    if (e.pointerId === evCache[i].pointerId) {\r\n      evCache[i] = e;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If two pointers are down, check for pinch gestures\r\n  if (evCache.length === 2) {\r\n    // Calculate the distance between the two pointers\r\n    const curDiff = Math.abs(evCache[0].clientX - evCache[1].clientX);\r\n\r\n    if (prevDiff > 0) {\r\n      // zoom in\r\n      if (curDiff > prevDiff) {\r\n        slider.value = Number(slider.value) + 2;\r\n        zoomImage(slider.value);\r\n      }\r\n      // zoom out\r\n      if (curDiff < prevDiff) {\r\n        slider.value = Number(slider.value) - 2;\r\n        zoomImage(slider.value);\r\n      }\r\n    }\r\n\r\n    prevDiff = curDiff;\r\n  }\r\n});\r\n\r\nconst onPointerUp = (e) => {\r\n  for (let i = 0; i < evCache.length; i++) {\r\n    if (evCache[i].pointerId === e.pointerId) {\r\n      evCache.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  // If the number of pointers down is less than two then reset diff tracker\r\n  if (evCache.length < 2) prevDiff = -1;\r\n};\r\n\r\ncanvas.addEventListener(\"pointerup\", onPointerUp);\r\ncanvas.addEventListener(\"pointercancel\", onPointerUp);\r\ncanvas.addEventListener(\"pointerout\", onPointerUp);\r\ncanvas.addEventListener(\"pointerleave\", onPointerUp);\r\n"],
  "mappings": "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",
  "names": []
}
